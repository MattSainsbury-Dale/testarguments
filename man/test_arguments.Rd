% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/test_arguments.R
\name{test_arguments}
\alias{test_arguments}
\title{Test (multiple) arguments of a prediction algorithm}
\usage{
test_arguments(fun, df_train, df_test, diagnostic_fun, arguments)
}
\arguments{
\item{fun}{prediction function}

\item{df_train}{training data}

\item{df_test}{testing data}

\item{diagnostic_fun}{the criteria with which the predictive performance will
be assessed}

\item{arguments}{named list of arguments to check. Each argument should
require atomic values only (a single number, string, etc.)}
}
\value{
a data.frame whose columns contain the diagnostics and run time, and
each row corresponds to a combination of the provided arguments
}
\description{
Test the performance of a prediction algorithm over a range of argument
values. Multiple arguments can be tested simultaneously.
}
\details{
\code{fun} should have formal arguments \code{df_train} and \code{df_test},
which are data used to train the model and test out-of-sample predictive
performance, respectively. The value of \code{fun} should be a matrix
with named columns and the same number of rows as \code{df_test}. We
\code{cbind} the output of \code{fun} to \code{df_test}, and pass this into
\code{diagnostic_fun}. Hence, since the number of columns in the returned
value of \code{fun} is arbitrary, on can test both predictions and prediction
uncertainty (e.g., by including prediction standard errors or predictive
interval bounds in the returned value of \code{fun}).
}
\examples{
## Load FRK package and create training and testing data
library("testarguments")
library("FRK")
library("sp")
data("Poisson_simulated")
n <- nrow(Poisson_simulated)
train_id <- sample(1:n, round(n/2))
df_train <- Poisson_simulated[train_id, ]
df_test  <- Poisson_simulated[-train_id, ]

## Define the function which creates predictions.
## In this example, we wish to test values of the arguments link and nres.
fun <- function(df_train, df_test, link, nres) {

  ## Convert dataframes to Spatial* objects (as required by FRK)
  coordinates(df_train) <- ~ x + y
  coordinates(df_test) <- ~ x + y

  BAUs <- auto_BAUs(manifold = plane(), data = rbind(df_train, df_test))

  ## Fit using df_train, predict at df_test locations
  S <- FRK(f = Z ~ 1, data = list(df_train), BAUs = BAUs, response = "poisson",
           link = link, nres = nres)
  pred <- predict(S, newdata = df_test, type = "response")

  ## NB: returned object needs to be a matrix or data.frame with named columns
  return(pred$newdata@data)
}


## diagnostic_fun should return a named vector
diagnostic_fun <- function(df_test) {
  with(df_test,
       c(RMSPE = sqrt(mean((p_Z - Z)^2)),
         coverage = mean((Z > Z_percentile_5) & (Z < Z_percentile_95))))
}

diagnostics <- test_arguments(fun, df_train, df_test, diagnostic_fun,
                              arguments = list(link = c("log", "square-root"),
                                               nres = 1:3))
## Visualise the performance
plot_diagnostics(diagnostics, c("nres", "link"))
plot_diagnostics(diagnostics, c("nres", "link"), focused_args = "nres")
}
\seealso{
\code{\link{plot_diagnostics}}
}
