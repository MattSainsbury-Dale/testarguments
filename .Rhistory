pred <- predict(S, newdata = df_test, type = "response")
## NB: returned object needs to be a named matrix
return(pred$newdata@data)
}
## diagnostic_fun should return a named vector
diagnostic_fun <- function(df_test) {
with(df_test,
RMSPE = sqrt(mean((p_Z - Z)^2)),
coverage = mean((Z > Z_percentile_5) & (Z < Z_percentile_95))
)
}
diagnostics <- test_arguments(fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("log", "square-root"),
nres = 1:2))
## Define the function which creates predictions.
## In this example, we wish to test values of the arguments link and nres.
fun <- function(df_train, df_test, link, nres) {
## Convert dataframes to Spatial* objects (as required by FRK)
coordinates(df_train) <- ~ x + y
coordinates(df_test) <- ~ x + y
BAUs <- auto_BAUs(manifold = plane(), data = rbind(df_train, df_test))
## Fit using df_train, predict at df_test locations
S <- FRK(f = Z ~ 1, data = list(df_train), BAUs = BAUs, response = "poisson",
link = link, nres = nres)
pred <- predict(S, newdata = df_test, type = "response")
## NB: returned object needs to be a named matrix
return(pred$newdata@data)
}
## diagnostic_fun should return a named vector
diagnostic_fun <- function(df_test) {
with(df_test,
RMSPE = sqrt(mean((p_Z - Z)^2)),
coverage = mean((Z > Z_percentile_5) & (Z < Z_percentile_95))
)
}
diagnostics <- test_arguments(fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("log", "square-root"),
nres = 1:2))
## Convert dataframes to Spatial* objects (as required by FRK)
coordinates(df_train) <- ~ x + y
coordinates(df_test) <- ~ x + y
BAUs <- auto_BAUs(manifold = plane(), data = rbind(df_train, df_test))
## Fit using df_train, predict at df_test locations
S <- FRK(f = Z ~ 1, data = list(df_train), BAUs = BAUs, response = "poisson",
link = link, nres = nres)
pred <- predict(S, newdata = df_test, type = "response")
nrow(pred$newdata)
nrow(df_test)
devtools::load_all(".")
data("Poisson_simulated")
n <- nrow(Poisson_simulated)
train_id <- sample(1:n, round(n/2))
df_train <- Poisson_simulated[train_id, ]
df_test  <- Poisson_simulated[-train_id, ]
## Define the function which creates predictions.
## In this example, we wish to test values of the arguments link and nres.
fun <- function(df_train, df_test, link, nres) {
## Convert dataframes to Spatial* objects (as required by FRK)
coordinates(df_train) <- ~ x + y
coordinates(df_test) <- ~ x + y
BAUs <- auto_BAUs(manifold = plane(), data = rbind(df_train, df_test))
## Fit using df_train, predict at df_test locations
S <- FRK(f = Z ~ 1, data = list(df_train), BAUs = BAUs, response = "poisson",
link = link, nres = nres)
pred <- predict(S, newdata = df_test, type = "response")
## NB: returned object needs to be a named matrix
return(pred$newdata@data)
}
## diagnostic_fun should return a named vector
diagnostic_fun <- function(df_test) {
with(df_test,
RMSPE = sqrt(mean((p_Z - Z)^2)),
coverage = mean((Z > Z_percentile_5) & (Z < Z_percentile_95))
)
}
diagnostics <- test_arguments(fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("log", "square-root"),
nres = 1:2))
is.matrix(pred)
devtools::load_all(".")
devtools::document()
?test_arguments
## Define the function which creates predictions.
## In this example, we wish to test values of the arguments link and nres.
fun <- function(df_train, df_test, link, nres) {
## Convert dataframes to Spatial* objects (as required by FRK)
coordinates(df_train) <- ~ x + y
coordinates(df_test) <- ~ x + y
BAUs <- auto_BAUs(manifold = plane(), data = rbind(df_train, df_test))
## Fit using df_train, predict at df_test locations
S <- FRK(f = Z ~ 1, data = list(df_train), BAUs = BAUs, response = "poisson",
link = link, nres = nres)
pred <- predict(S, newdata = df_test, type = "response")
## NB: returned object needs to be a named matrix
return(pred$newdata@data)
}
## diagnostic_fun should return a named vector
diagnostic_fun <- function(df_test) {
with(df_test,
RMSPE = sqrt(mean((p_Z - Z)^2)),
coverage = mean((Z > Z_percentile_5) & (Z < Z_percentile_95))
)
}
diagnostics <- test_arguments(fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("log", "square-root"),
nres = 1:2))
devtools::load_all(".")
diagnostics <- test_arguments(fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("log", "square-root"),
nres = 1:2))
devtools::load_all(".")
diagnostics <- test_arguments(fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("log", "square-root"),
nres = 1:2))
diagnostic_fun(df_test)
diagnostic_fun
with(df_test,
RMSPE = sqrt(mean((p_Z - Z)^2)),
coverage = mean((Z > Z_percentile_5) & (Z < Z_percentile_95))
)
## diagnostic_fun should return a named vector
diagnostic_fun <- function(df_test) {
with(df_test,
c(RMSPE = sqrt(mean((p_Z - Z)^2)),
coverage = mean((Z > Z_percentile_5) & (Z < Z_percentile_95))))
}
diagnostics <- test_arguments(fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("log", "square-root"),
nres = 1:2))
diagnostic_fun(df_test)
cbind(diagnostic_fun(df_test), Time = unname(time))
c(diagnostic_fun(df_test), Time = unname(time))
current_diagnostics <- c(diagnostic_fun(df_test), Time = unname(time))
## record the current arguments
current_diagnostics[, names(arguments)] <- arguments[i, ]
## record the current arguments
current_diagnostics[names(arguments)] <- arguments[i, ]
current_diagnostics
## Convert to data.frame so we can add the current arugments (which may
## contain strings)
c(R = "a", x = 1)
current_diagnostics <- c(diagnostic_fun(df_test), Time = unname(time))
current_diagnostics <- as.data.frame(current_diagnostics)
current_diagnostics
current_diagnostics <- c(diagnostic_fun(df_test), Time = unname(time))
current_diagnostics <- as.data.frame(as.list(current_diagnostics))
current_diagnostics
## record the current arguments
current_diagnostics[names(arguments)] <- arguments[i, ]
current_diagnostics
devtools::load_all(".")
devtools::load_all(".")
devtools::document()
?test_arguments
## diagnostic_fun should return a named vector
diagnostic_fun <- function(df_test) {
with(df_test,
c(RMSPE = sqrt(mean((p_Z - Z)^2)),
coverage = mean((Z > Z_percentile_5) & (Z < Z_percentile_95))))
}
diagnostics <- test_arguments(fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("log", "square-root"),
nres = 1:2))
devtools::load_all(".")
## diagnostic_fun should return a named vector
diagnostic_fun <- function(df_test) {
with(df_test,
c(RMSPE = sqrt(mean((p_Z - Z)^2)),
coverage = mean((Z > Z_percentile_5) & (Z < Z_percentile_95))))
}
diagnostics <- test_arguments(fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("log", "square-root"),
nres = 1:2))
diagnostics
devtools::load_all(".")
## ADD plot_diagnostics()
long_diagnostics <- .long_diagnostic_df(diagnostics, argument_names = c("link", "nres"))
long_diagnostics
long_diagnostics <- .long_diagnostic_df(diagnostics, argument_names = c("nres"))
long_diagnostics
## ADD plot_diagnostics()
long_diagnostics <- .long_diagnostic_df(diagnostics, argument_names = c("link", "nres"))
long_diagnostics
## ADD plot_diagnostics()
long_diagnostics <- .long_diagnostic_df(diagnostics, argument_names = c("link", "nres"))
long_diagnostics
long_diagnostics <- .long_diagnostic_df(diagnostics, argument_names = c("nres"))
long_diagnostics
devtools::load_all(".")
## ADD plot_diagnostics()
plot_diagnostics(diagnostics, c("nres", "link"))
devtools::load_all(".")
## ADD plot_diagnostics()
plot_diagnostics(diagnostics, c("nres", "link"))
paste(". ~ ", "Diagnostic + ", paste(arg_names, collapse = " + ")) %>%
as.formula() %>%
aggregate(long_df, mean)
devtools::load_all(".")
## ADD plot_diagnostics()
plot_diagnostics(diagnostics, c("nres", "link"))
paste(". ~ ", "Diagnostic + ", paste(arg_names, collapse = " + ")) %>%
as.formula() %>%
aggregate(long_df, mean)
devtools::load_all(".")
devtools::document()
devtools::load_all(".")
## ADD plot_diagnostics()
plot_diagnostics(diagnostics, c("nres", "link"))
paste(". ~ ", "Diagnostic + ", paste(arg_names, collapse = " + ")) %>%
as.formula() %>%
aggregate(long_df, mean)
library("magrittr")
long_diagnostics %>% head
devtools::load_all(".")
## ADD plot_diagnostics()
plot_diagnostics(diagnostics, c("nres", "link"))
paste(". ~ ", "Diagnostic + ", paste(arg_names, collapse = " + ")) %>%
as.formula() %>%
aggregate(long_df, mean)
devtools::load_all(".")
## ADD plot_diagnostics()
plot_diagnostics(diagnostics, c("nres", "link"))
paste(". ~ ", "Diagnostic + ", paste(focused_args, collapse = " + ")) %>%
as.formula() %>%
aggregate(long_df, mean)
plot_diagnostics(diagnostics, c("nres"))
paste(". ~ ", "Diagnostic + ", paste(focused_args, collapse = " + ")) %>%
as.formula() %>%
aggregate(long_df, mean)
plot_diagnostics(diagnostics, c("nres", "link"), "nres")
focused_args
paste(". ~ ", "Diagnostic + ", paste(focused_args, collapse = " + ")) %>%
as.formula() %>%
aggregate(long_df, mean)
arg_names
length(focused_args) > 4
devtools::load_all(".")
devtools::load_all(".")
## ADD plot_diagnostics()
plot_diagnostics(diagnostics, c("nres", "link"))
devtools::load_all(".")
## ADD plot_diagnostics()
plot_diagnostics(diagnostics, c("nres", "link"))
library(ggplot2)
## ADD plot_diagnostics()
plot_diagnostics(diagnostics, c("nres", "link"))
plot_diagnostics(diagnostics, c("nres", "link"), focused_args = "nres")
diagnostics <- test_arguments(fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("log", "square-root"),
nres = 1:3))
## ADD plot_diagnostics()
plot_diagnostics(diagnostics, c("nres", "link"))
plot_diagnostics(diagnostics, c("nres", "link"), focused_args = "nres")
plot_diagnostics(diagnostics, c("link", "nres"))
## ADD plot_diagnostics()
plot_diagnostics(diagnostics, c("nres", "link"))
plot_diagnostics(diagnostics, c("nres", "link"), focused_args = "nres")
plot_diagnostics(diagnostics, c("nres", "link"), focused_args = "link")
plot_diagnostics(diagnostics, c("nres", "link"), focused_args = "nres")
## ADD plot_diagnostics()
plot_diagnostics(diagnostics, c("nres", "link"))
devtools::load_all(".")
plot_diagnostics(diagnostics, c("nres", "link"), focused_args = "nres")
is.numeric(long_df[, focused_args[1]])
devtools::load_all(".")
plot_diagnostics(diagnostics, c("nres", "link"), focused_args = "nres")
plot_diagnostics(diagnostics, c("nres", "link"), focused_args = "link") # can't be done because link is descrete
g <- g + aes_string(x = focused_args[1])
g + geom_point() + geom_line() + theme_bw() + labs(y = "")
g <- g + aes_string(x = focused_args[1])
g <- ggplot(long_df, aes(y = value))
g <- g + aes_string(x = focused_args[1])
g + geom_point() + geom_line() + theme_bw() + labs(y = "")
df_long
long_df
g + geom_point() + geom_line() + theme_bw() + labs(y = "") +
scale_x_continuous(breaks = unique(long_df[, focused_args[1]]))
g + geom_point() + geom_line() + theme_bw() + labs(y = "")
g <-  g + geom_point() + geom_line() + theme_bw() + labs(y = "")
g + facet_wrap(. ~Diagnostic, scales = "free", nrow = 1)
devtools::load_all(".")
## ADD plot_diagnostics()
plot_diagnostics(diagnostics, c("nres", "link"))
plot_diagnostics(diagnostics, c("nres", "link"), focused_args = "nres")
plot_diagnostics(diagnostics, c("nres", "link"), focused_args = "link") # can't be done because link is descrete
devtools::load_all(".")
devtools::load_all(".")
devtools::document()
class(diagnostics)
diagnostics
devtools::load_all(".")
devtools:;document(0)
devtools::document()
?plot_diagnostics
devtools::load_all(".")
devtools::document()
?plot_diagnostics
devtools::document()
?plot_diagnostics
devtools::load_all(".")
devtools::document()
?plot_diagnostics
devtools::load_all(".")
devtools::document()
?plot_diagnostics
devtools::load_all(".")
devtools::document()
?plot_diagnostics
?test_arguments
## Load FRK package and create training and testing data
library("FRK")
library("sp")
data("Poisson_simulated")
n <- nrow(Poisson_simulated)
train_id <- sample(1:n, round(n/2))
df_train <- Poisson_simulated[train_id, ]
df_test  <- Poisson_simulated[-train_id, ]
## Define the function which creates predictions.
## In this example, we wish to test values of the arguments link and nres.
fun <- function(df_train, df_test, link, nres) {
## Convert dataframes to Spatial* objects (as required by FRK)
coordinates(df_train) <- ~ x + y
coordinates(df_test) <- ~ x + y
BAUs <- auto_BAUs(manifold = plane(), data = rbind(df_train, df_test))
## Fit using df_train, predict at df_test locations
S <- FRK(f = Z ~ 1, data = list(df_train), BAUs = BAUs, response = "poisson",
link = link, nres = nres)
pred <- predict(S, newdata = df_test, type = "response")
## NB: returned object needs to be a matrix or data.frame with named columns
return(pred$newdata@data)
}
## diagnostic_fun should return a named vector
diagnostic_fun <- function(df_test) {
with(df_test,
c(RMSPE = sqrt(mean((p_Z - Z)^2)),
coverage = mean((Z > Z_percentile_5) & (Z < Z_percentile_95))))
}
diagnostics <- test_arguments(fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("log", "square-root"),
nres = 1:3))
## Load FRK package and create training and testing data
library("testArguments")
devtools::load_all(".")
library("FRK")
library("sp")
data("Poisson_simulated")
n <- nrow(Poisson_simulated)
train_id <- sample(1:n, round(n/2))
df_train <- Poisson_simulated[train_id, ]
df_test  <- Poisson_simulated[-train_id, ]
## Define the function which creates predictions.
## In this example, we wish to test values of the arguments link and nres.
fun <- function(df_train, df_test, link, nres) {
## Convert dataframes to Spatial* objects (as required by FRK)
coordinates(df_train) <- ~ x + y
coordinates(df_test) <- ~ x + y
BAUs <- auto_BAUs(manifold = plane(), data = rbind(df_train, df_test))
## Fit using df_train, predict at df_test locations
S <- FRK(f = Z ~ 1, data = list(df_train), BAUs = BAUs, response = "poisson",
link = link, nres = nres)
pred <- predict(S, newdata = df_test, type = "response")
## NB: returned object needs to be a matrix or data.frame with named columns
return(pred$newdata@data)
}
## diagnostic_fun should return a named vector
diagnostic_fun <- function(df_test) {
with(df_test,
c(RMSPE = sqrt(mean((p_Z - Z)^2)),
coverage = mean((Z > Z_percentile_5) & (Z < Z_percentile_95))))
}
diagnostics <- test_arguments(fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("log", "square-root"),
nres = 1:3))
## Visualise the performance
plot_diagnostics(diagnostics, c("nres", "link"))
devtools::load_all(".")
devtools::document()
devtools::load_all(".")
devtools::document()
devtools::load_all(".")
devtools::document()
## Visualise the performance
plot_diagnostics(diagnostics, c("nres", "link"))
diagnostics <- test_arguments(fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("log", "square-root"),
nres = 1:3))
## Visualise the performance
plot_diagnostics(diagnostics, c("nres", "link"))
plot_diagnostics(diagnostics, c("nres", "link"), focused_args = "nres")
plot_diagnostics(diagnostics, c("nres", "link"), focused_args = "log")
plot_diagnostics(diagnostics, c("nres", "link"), focused_args = "link")
devtools::load_all(".")
devtools::document
devtools::document()
devtools::load_all(".")
devtools::document()
devtools::load_all(".")
devtools::load_all(".")
?test_arguments
## Load FRK package and create training and testing data
library("testarguments")
library("FRK")
library("sp")
data("Poisson_simulated")
n <- nrow(Poisson_simulated)
train_id <- sample(1:n, round(n/2))
df_train <- Poisson_simulated[train_id, ]
df_test  <- Poisson_simulated[-train_id, ]
## Define the function which creates predictions.
## In this example, we wish to test values of the arguments link and nres.
fun <- function(df_train, df_test, link, nres) {
## Convert dataframes to Spatial* objects (as required by FRK)
coordinates(df_train) <- ~ x + y
coordinates(df_test) <- ~ x + y
BAUs <- auto_BAUs(manifold = plane(), data = rbind(df_train, df_test))
## Fit using df_train, predict at df_test locations
S <- FRK(f = Z ~ 1, data = list(df_train), BAUs = BAUs, response = "poisson",
link = link, nres = nres)
pred <- predict(S, newdata = df_test, type = "response")
## NB: returned object needs to be a matrix or data.frame with named columns
return(pred$newdata@data)
}
## diagnostic_fun should return a named vector
diagnostic_fun <- function(df_test) {
with(df_test,
c(RMSPE = sqrt(mean((p_Z - Z)^2)),
coverage = mean((Z > Z_percentile_5) & (Z < Z_percentile_95))))
}
diagnostics <- test_arguments(fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("log", "square-root"),
nres = 1:3))
## Visualise the performance
plot_diagnostics(diagnostics, c("nres", "link"))
plot_diagnostics(diagnostics, c("nres", "link"), focused_args = "nres")
devtools::load_all(".")
library("FRK")
library("sp")
library("pROC") # AUC score
n <- 5000                                                  # sample size
RNGversion("3.6.0"); set.seed(1)
data("MODIS_cloud_df") # MODIS dataframe stored in FRK (FRKTMB branch)
train_id <- sample(1:nrow(MODIS_cloud_df), n, replace = FALSE)
df_train <- MODIS_cloud_df[train_id, ]                     # training set
df_test  <- MODIS_cloud_df[-train_id, ]                    # testing set
fun <- function(df_train, df_test, link, nres) {
## Convert dataframes to Spatial* objects (as required by FRK)
coordinates(df_train) <- ~ x + y
coordinates(df_test) <- ~ x + y
## BAUs (just use a grid over the spatial domain of interest)
BAUs    <- SpatialPixelsDataFrame(points = expand.grid(x = 1:225, y = 1:150),
data = expand.grid(x = 1:225, y = 1:150))
## Fit using df_train
df_train$k_Z <- 1 # size parameter of the binomial distribution
S <- FRK(f = z ~ 1, data = list(df_train), BAUs = BAUs, response = "binomial",
link = link, nres = nres)
## Predict using df_test
pred <- predict(S, newdata = df_test, type = "response")
## Returned object must be a matrix-like object with named columns
return(pred$newdata@data)
}
diagnostic_fun <- function(df) {
with(df, c(
Brier = mean((z - p_Z)^2),
AUC = as.numeric(pROC::auc(z, p_Z))
))
}
diagnostic_fun <- function(df) {
with(df, c(
Brier = mean((z - p_Z)^2),
AUC = as.numeric(pROC::auc(z, p_Z))
))
}
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("logit", "probit"), nres = 1:3)
)
plot_diagnostics(testargs_object)
plot_diagnostics(testargs_object, focused_args = "nres")
optimal_arguments(testargs_object)
testargs_object <- readRDS("~/Dropbox/testarguments/Heaton_testargs_object.rds")
optimality_criterion <- list(RMSE = which.min, MAE = which.min, CRPS = which.min,
Cov95 = function(x) which.min(abs(x - 0.95)),
int_score = which.min, Time = which.min)
optimal_arguments(testargs_object, optimality_criterion)
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("logit", "probit"), nres = 1:3)
)
optimal_arguments(testargs_object)
optimality_criterion <- list(Brier = which.min, AUC = which.max, Time = which.min)
Objects of class `testargs` can be combined using `bind()`. For computing the optimal arguments from a `testargs` object, see `optimal_arguments()`. The optimality criterion is diagnsotics dependent (e.g., we typically wish to *minimise* the Brier score and run time, but *maximise* the AUC score). For this reason, `optimal_arguments()` allows one to set the optimality criterion for each rule individually.
```r
optimality_criterion <- list(Brier = which.min, AUC = which.max, Time = which.min)
optimal_arguments(testargs_object, optimality_criterion)
```
More complicated criteria are possible: For instance, if one of the diagnostics is Cov90 (the coverage from 90% prediction intervals), then one would use something like `list(Cov90 = function(x) which.min(abs(x - 0.90)))`.
optimal_arguments(testargs_object, optimality_criterion)
optimality_criterion <- list(Brier = which.min, AUC = which.max, Time = which.min)
optimal_arguments(testargs_object, optimality_criterion)
xtable::xtable(optimal_arguments(testargs_object, optimality_criterion))
?xtable::xtable
xtable::xtable(optimal_arguments(testargs_object, optimality_criterion), type = "HTML")
xtable::xtable(optimal_arguments(testargs_object, optimality_criterion), type = "html")
print(xtable::xtable(optimal_arguments(testargs_object, optimality_criterion)), type = "html")
list(min)
lapply(1:3, min)
devtools::load_all(".")
optimal_arguments(testargs_object, optimality_criterion)
optimal_arguments(testargs_object)
testargs_object <- readRDS("~/Dropbox/testarguments/Heaton_testargs_object.rds")
devtools::load_all(".")
plot_diagnostics(testargs_object) + scale_x_continuous(trans = "log10")
