with(df, c(
Brier = mean((z - p_Z)^2),
AUC = as.numeric(pROC::auc(z, p_Z))
))
}
diagnostic_fun <- function(df) {
with(df, c(
Brier = mean((z - p_Z)^2),
AUC = as.numeric(pROC::auc(z, p_Z))
))
}
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("logit", "probit"), nres = 1:3)
)
plot_diagnostics(testargs_object)
plot_diagnostics(testargs_object, focused_args = "nres")
optimal_arguments(testargs_object)
testargs_object <- readRDS("~/Dropbox/testarguments/Heaton_testargs_object.rds")
optimality_criterion <- list(RMSE = which.min, MAE = which.min, CRPS = which.min,
Cov95 = function(x) which.min(abs(x - 0.95)),
int_score = which.min, Time = which.min)
optimal_arguments(testargs_object, optimality_criterion)
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(link = c("logit", "probit"), nres = 1:3)
)
optimal_arguments(testargs_object)
optimality_criterion <- list(Brier = which.min, AUC = which.max, Time = which.min)
Objects of class `testargs` can be combined using `bind()`. For computing the optimal arguments from a `testargs` object, see `optimal_arguments()`. The optimality criterion is diagnsotics dependent (e.g., we typically wish to *minimise* the Brier score and run time, but *maximise* the AUC score). For this reason, `optimal_arguments()` allows one to set the optimality criterion for each rule individually.
```r
optimality_criterion <- list(Brier = which.min, AUC = which.max, Time = which.min)
optimal_arguments(testargs_object, optimality_criterion)
```
More complicated criteria are possible: For instance, if one of the diagnostics is Cov90 (the coverage from 90% prediction intervals), then one would use something like `list(Cov90 = function(x) which.min(abs(x - 0.90)))`.
optimal_arguments(testargs_object, optimality_criterion)
optimality_criterion <- list(Brier = which.min, AUC = which.max, Time = which.min)
optimal_arguments(testargs_object, optimality_criterion)
xtable::xtable(optimal_arguments(testargs_object, optimality_criterion))
?xtable::xtable
xtable::xtable(optimal_arguments(testargs_object, optimality_criterion), type = "HTML")
xtable::xtable(optimal_arguments(testargs_object, optimality_criterion), type = "html")
print(xtable::xtable(optimal_arguments(testargs_object, optimality_criterion)), type = "html")
list(min)
lapply(1:3, min)
devtools::load_all(".")
optimal_arguments(testargs_object, optimality_criterion)
optimal_arguments(testargs_object)
testargs_object <- readRDS("~/Dropbox/testarguments/Heaton_testargs_object.rds")
devtools::load_all(".")
plot_diagnostics(testargs_object) + scale_x_continuous(trans = "log10")
x <- seq(0, 1, length.out = 100)
x <- seq(0, 1, length.out = 100)
mu <- 5 + 0.3 * x + 0.4 * x^2 + 0.7 * x^3
Z <- mu + rnorm(n, sd = 0.1)
df_train <- data.frame(x = x, Z = Z)
n <- 100                                          # data set size
x <- seq(0, 1, length.out = n)                    # covariate
mu <- 1 + x + x^2 + x^3                           # true mean
Z <- mu + rnorm(n, sd = 0.1)                      # data
df <- data.frame(x = x, Z = Z)
train_id <- sample(1:n, n/2, replace = FALSE)
df_train <- df[train_id, ]                        # training set
df_test  <- df[-train_id, ]                       # testing set
plot(x, Z)
n <- 100                                          # data set size
x <- seq(0, 5, length.out = n)                    # covariate
mu <- 1 + x + x^2 + x^3                           # true mean
Z <- mu + rnorm(n, sd = 0.1)                      # data
plot(x, Z)
n <- 100                                          # data set size
x <- seq(0, 1, length.out = n)                    # covariate
mu <- 1 + x + x^2 + x^3                           # true mean
Z <- mu + rnorm(n, sd = 0.1)                      # data
plot(x, Z)
n <- 100                                          # data set size
x <- seq(-1, 1, length.out = n)                    # covariate
mu <- 1 + x + x^2 + x^3 - x^4                           # true mean
Z <- mu + rnorm(n, sd = 0.1)                      # data
plot(x, Z)
n <- 100                                          # data set size
x <- seq(-1, 1, length.out = n)                   # covariate
mu <- 1 + x + x^2 + x^3                           # true mean
Z <- mu + rnorm(n, sd = 0.1)                      # data
plot(x, Z)
n <- 100                                          # data set size
x <- seq(-1, 1, length.out = n)                   # covariate
mu <- 1 + x + -x^2 + x^3                           # true mean
Z <- mu + rnorm(n, sd = 0.1)                      # data
plot(x, Z)
n <- 100                                          # data set size
x <- seq(-1, 1, length.out = n)                   # covariate
mu <- 1 + x + x^2 + x^3 + x^4                         # true mean
Z <- mu + rnorm(n, sd = 0.1)                      # data
plot(x, Z)
n <- 100                                          # data set size
x <- seq(-1, 1, length.out = n)                   # covariate
mu <- 1 + x + x^2 + x^3 + -x^4                         # true mean
Z <- mu + rnorm(n, sd = 0.1)                      # data
plot(x, Z)
n <- 100                                          # data set size
x <- seq(-1, 1, length.out = n)                   # covariate
mu <- 1 + x + x^2 + x^3 + -x^4                         # true mean
Z <- mu + rnorm(n, sd = 0.05)                      # data
plot(x, Z)
n <- 100                                          # data set size
x <- seq(-1, 1, length.out = n)                   # covariate
mu <- 1 + x + x^2 + 3 * x^3 + -x^4                         # true mean
Z <- mu + rnorm(n, sd = 0.05)                      # data
plot(x, Z)
n <- 100                                          # data set size
x <- seq(-1, 1, length.out = n)                   # covariate
mu <- 1 + x + x^2 + 3 * x^3 - 4 * x^4                         # true mean
Z <- mu + rnorm(n, sd = 0.05)                      # data
plot(x, Z)
n <- 100                                          # data set size
x <- seq(-1, 1, length.out = n)                   # covariate
mu <- 1 + x + x^2 + 3 * x^3 - 2 * x^4                         # true mean
Z <- mu + rnorm(n, sd = 0.05)                      # data
plot(x, Z)
mu <- 1 + x + 2 * x^2 + 3 * x^3 - 2 * x^4                         # true mean
Z <- mu + rnorm(n, sd = 0.05)                      # data
plot(x, Z)
mu <- 1 + x + 2 * x^2 + 3 * x^3 - 3 * x^4                         # true mean
Z <- mu + rnorm(n, sd = 0.05)                      # data
plot(x, Z)
mu <- 1 + x + 2 * x^2 + 3 * x^3 - 3 * x^4                         # true mean
Z <- mu + rnorm(n, sd = 0.05)                      # data
plot(x, Z)
mu <- 1 + x + x^2 + x^3 + x^4                         # true mean
Z <- mu + rnorm(n, sd = 0.05)                      # data
plot(x, Z)
x <- seq(-2, 2, length.out = n)                   # covariate
mu <- 1 + x + 2 * x^2 + 3 * x^3 - 3 * x^4                         # true mean
mu <- 1 + x + x^2 + x^3 + x^4                         # true mean
Z <- mu + rnorm(n, sd = 0.05)                      # data
plot(x, Z)
mu <- 1 + x + x^2 + x^3 - x^4                         # true mean
Z <- mu + rnorm(n, sd = 0.05)                      # data
plot(x, Z)
n <- 100                                          # data set size
x <- seq(-1, 2, length.out = n)                   # covariate
mu <- 1 + x + 2 * x^2 + 3 * x^3 - 3 * x^4                         # true mean
mu <- 1 + x + x^2 + x^3 - x^4                         # true mean
Z <- mu + rnorm(n, sd = 0.05)                      # data
plot(x, Z)
M <- lm(Z ~ poly(x,4), data = df_train)
predict.lm(newdata = df_test)
predict.lm(M, newdata = df_test)
Z_hat <- predict.lm(M, newdata = df_test)
data.frame(Z_hat = Z_hat)
diagnostic_fun <- function(df) {
with(df, c(
RMSE = mean((Z - Z_hat)^2)
))
}
Z_hat <- predict.lm(M, newdata = df_test, interval = "confidence", level = 0.99)
Z_hat
Z_hat %>% head
head(Z_hat)
pred <- predict.lm(M, newdata = df_test, interval = "confidence", level = 0.99)
class(pred)
diagnostic_fun <- function(df) {
with(df, c(
RMSE = sqrt(mean((Z - fit)^2)),
coverage = mean((Z < upr) & (Z > lwr))
))
}
n <- 100                                          # data set size
x <- seq(-1, 2, length.out = n)                   # covariate
mu <- 1 + x + x^2 + x^3 - x^4                     # true mean
Z <- mu + rnorm(n, sd = 0.05)                     # data
plot(x, Z)
df <- data.frame(x = x, Z = Z)
train_id <- sample(1:n, n/2, replace = FALSE)
df_train <- df[train_id, ]                        # training set
df_test  <- df[-train_id, ]                       # testing set
fun <- function(df_train, df_test, degree) {
## Fit a polygo
M <- lm(Z ~ poly(x, degree), data = df_train)
pred <- predict.lm(M, newdata = df_test, interval = "confidence", level = 0.99)
## NB: Predictions must be a matrix-like object with named columns.
## In this example, pred is a matrix with columns fit (the predicted-values),
## and lwr and upr (the lower and upper bounds of the 90% confidence interval)
return(pred)
}
diagnostic_fun <- function(df) {
with(df, c(
RMSE = sqrt(mean((Z - fit)^2)),
coverage = mean((Z < upr) & (Z > lwr)),
interval_width = mean(upr - lwr)
))
}
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(degree = 1:4)
)
devtools::load_all(".")
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(degree = 1:4)
)
pred
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(degree = 1:4)
)
is.null(names(pred))
head(pred)
names(pred) <- c("a", "b", "c")
head(pred)
is.null(names(pred))
pred <- predict.lm(M, newdata = df_test, interval = "confidence", level = 0.99)
head(pred)
is.null(names(pred))
names(pred) <- c("a", "b", "c")
head(pred)
names(pred) <- c("a", "b", "c")
head(pred)
pred <- predict.lm(M, newdata = df_test, interval = "confidence", level = 0.99)
pred[1, ]
pred[2, ]
slots(pred)
slotNames(pred)
slotNames("matrix")
?`matrix-class`
dimnames(pred)
dimnames(pred)[[2]]
dimnames(data.frame(x = 5))
dimanmes(matrix(1))
dimnames(matrix(1))
names(pred) <- dimnames(pred)[[2]]
devtools::load_all(".")
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(degree = 1:4)
)
plot_diagnostics(testargs_object)
diagnostic_fun <- function(df) {
with(df, c(
RMSE = sqrt(mean((Z - fit)^2))
))
}
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(degree = 1:4)
)
plot_diagnostics(testargs_object)
n <- 10000                                        # data set size
x <- seq(-1, 2, length.out = n)                   # covariate
mu <- 1 + x + x^2 + x^3 - x^4                     # true mean
Z <- mu + rnorm(n, sd = 0.05)                     # data
plot(x, Z)
df <- data.frame(x = x, Z = Z)
train_id <- sample(1:n, n/2, replace = FALSE)
df_train <- df[train_id, ]                        # training set
df_test  <- df[-train_id, ]                       # testing set
fun <- function(df_train, df_test, degree) {
## Fit a polygo
M <- lm(Z ~ poly(x, degree), data = df_train)
pred <- predict.lm(M, newdata = df_test, interval = "confidence", level = 0.99)
## NB: Predictions must be a matrix-like object with named columns.
## In this example, pred is a matrix with columns fit (the predicted-values),
## and lwr and upr (the lower and upper bounds of the 90% confidence interval)
return(pred)
}
diagnostic_fun <- function(df) {
with(df, c(
RMSE = sqrt(mean((Z - fit)^2))
))
}
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(degree = 1:4)
)
plot_diagnostics(testargs_object)
n <- 100000                                       # data set size
x <- seq(-1, 2, length.out = n)                   # covariate
mu <- 1 + x + x^2 + x^3 - x^4                     # true mean
Z <- mu + rnorm(n, sd = 0.05)                     # data
df <- data.frame(x = x, Z = Z)
train_id <- sample(1:n, n/2, replace = FALSE)
df_train <- df[train_id, ]                        # training set
df_test  <- df[-train_id, ]                       # testing set
fun <- function(df_train, df_test, degree) {
## Fit a polygo
M <- lm(Z ~ poly(x, degree), data = df_train)
pred <- predict.lm(M, newdata = df_test, interval = "confidence", level = 0.99)
## NB: Predictions must be a matrix-like object with named columns.
## In this example, pred is a matrix with columns fit (the predicted-values),
## and lwr and upr (the lower and upper bounds of the 90% confidence interval)
return(pred)
}
diagnostic_fun <- function(df) {
with(df, c(
RMSE = sqrt(mean((Z - fit)^2))
))
}
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(degree = 1:4)
)
plot_diagnostics(testargs_object)
n <- 100                                          # data set size
x <- seq(-1, 2, length.out = n)                   # covariate
mu <- 1 + x + x^2 + x^3 - x^4                     # true mean
Z <- mu + rnorm(n, sd = 0.05)                     # data
df <- data.frame(x = x, Z = Z)
train_id <- sample(1:n, n/2, replace = FALSE)
df_train <- df[train_id, ]                        # training set
df_test  <- df[-train_id, ]                       # testing set
fun <- function(df_train, df_test, degree) {
## Fit a polygo
M <- lm(Z ~ poly(x, degree), data = df_train)
pred <- predict.lm(M, newdata = df_test, interval = "confidence", level = 0.99)
## NB: Predictions must be a matrix-like object with named columns.
## In this example, pred is a matrix with columns fit (the predicted-values),
## and lwr and upr (the lower and upper bounds of the 90% confidence interval)
return(pred)
}
diagnostic_fun <- function(df) {
with(df, c(
RMSE = sqrt(mean((Z - fit)^2))
))
}
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(degree = 1:4)
)
plot_diagnostics(testargs_object)
diagnostic_fun <- function(df) {
with(df, c(
RMSE = sqrt(mean((Z - fit)^2)),
MAE  = mean(abs(Z - fit))
))
}
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(degree = 1:4)
)
plot_diagnostics(testargs_object)
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(degree = 0:4)
)
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(degree = 1:4)
)
plot_diagnostics(testargs_object)
pred <- predict.lm(M, newdata = df_test)      # predict over the test set
pred
class(pred)
## NB: Predictions must be a matrix-like object with named columns.
## In this example, pred is a matrix with columns fit (the predicted-values)
names(pred) <- "fit"
pred
pred <- predict.lm(M, newdata = df_test)      # predict over the test set
pred_values <- predict.lm(M, newdata = df_test) # Predict over the test set
as.matrix(pred_values)
n <- 100                                          # data set size
x <- seq(-1, 2, length.out = n)                   # covariate
mu <- 1 + x + x^2 + x^3 - x^4                     # true mean
Z <- mu + rnorm(n, sd = 0.05)                     # data
df <- data.frame(x = x, Z = Z)
train_id <- sample(1:n, n/2, replace = FALSE)
df_train <- df[train_id, ]                        # training set
df_test  <- df[-train_id, ]                       # testing set
fun <- function(df_train, df_test, d) {
## Fit a polynomial model of degree d, and predict over the test set
M <- lm(Z ~ poly(x, d), data = df_train)
pred <- predict.lm(M, newdata = df_test)
## NB: Predictions must be a matrix-like object with named columns
pred <- as.matrix(pred)
names(pred) <- "fit"
return(pred)
}
diagnostic_fun <- function(df) {
with(df, c(
RMSE = sqrt(mean((Z - fit)^2)),
MAE  = mean(abs(Z - fit))
))
}
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(d = 1:4)
)
d = 1
## Fit a polynomial model of degree d, and predict over the test set
M <- lm(Z ~ poly(x, d), data = df_train)
pred <- predict.lm(M, newdata = df_test)
## NB: Predictions must be a matrix-like object with named columns
pred <- as.matrix(pred)
names(pred) <- "fit"
head(pred)
colnames(pred) <- "fit"
head(pred)
fun <- function(df_train, df_test, d) {
## Fit a polynomial model of degree d, and predict over the test set
M <- lm(Z ~ poly(x, d), data = df_train)
pred <- predict.lm(M, newdata = df_test)
## NB: Predictions must be a matrix-like object with named columns
pred <- as.matrix(pred)
colnames(pred) <- "fit"
return(pred)
}
diagnostic_fun <- function(df) {
with(df, c(
RMSE = sqrt(mean((Z - fit)^2)),
MAE  = mean(abs(Z - fit))
))
}
testargs_object <- test_arguments(
fun, df_train, df_test, diagnostic_fun,
arguments = list(d = 1:4)
)
plot_diagnostics(testargs_object)
optimal_arguments(testargs_object)
?lm
devtools::load_all(".")
vignette("testarguments")
?glm
devtools::build_vignettes()
vignette("testarguments")
devtools::build_vignettes()
vignette("testarguments")
devtools::build_vignettes()
vignette("testarguments")
devtools::build_vignettes()
vignette("testarguments")
devtools::build_vignettes()
vignette("testarguments")
devtools::build_vignettes()
devtools::build_vignettes()
vignette("testarguments")
devtools::build_vignettes()
vignette("testarguments")
devtools::build_vignettes()
vignette("testarguments")
devtools::build_vignettes()
vignette("testarguments")
devtools::document()
devtools::build_manual()
devtools::check()
devtools::load_all(".")
vignette("testarguments")
library("devtools")
document()
build_vignettes()
document()
build_vignettes()
vignette("testarguments")
document()
vignette("testarguments")
build_vignettes()
vignette("testarguments")
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
devtools::build_manual()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::build_manual()
R.version
devtools::document()
devtools::build_manual()
R.version
devtools::document()
install.packages("devtools")
devtools::check()
install.packages("ggplot2")
library("devtools")
devtools::load_all()
install.packages('reshape2','plyr','dplyr')
install.packages(c('reshape2','plyr','dplyr'))
devtools::load_all()
devtools::check()
devtools::document()
devtools::build_vignettes()
.Last.error.trace
devtools::load_all(".")
devtools::load_all(".")
R.version
devtools::document()
devtools::build_vignettes()
devtools::check()
vignette("testarguments")
vignette("testarguments")
devtools::load_all(".")
devtools::document()
devtools::build_manual()
vignette("testarguments")
devtools::load_all(".")
devtools::document()
devtools::build_manual()
vignette("testarguments")
devtools::install_github("MattSainsbury-Dale/testarguments")
vignette("testarguments")
vignette("testarguments", build_vignette = TRUE)
devtools::install_github("MattSainsbury-Dale/testarguments", build_vignettes = TRUE)
devtools::install_github("MattSainsbury-Dale/testarguments", build_vignettes = TRUE, force = TRUE)
vignette("testarguments")
devtools::install_github("MattSainsbury-Dale/testarguments", build_vignettes = TRUE, force = TRUE)
vignette("testarguments")
?testargs
?test_arguments
library("testarguments")
?test_arguments
